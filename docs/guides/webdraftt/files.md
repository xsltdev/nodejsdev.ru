# Файлы

Для работы с файлами в Node.js используется встроенный модуль `fs`, который выполняет все синхронные и асинхронные операции ввода/вывода применительно к файлам. Чтение и запись файла могут осуществляться одним из двух способов:

-   с использованием [`Buffer`](../../api/buffer.md);
-   через создание соответствующего потока.

## Чтение файлов и директорий

Для чтения файла в асинхронном режиме используется метод Node.js `readFile()`, который принимает три параметра:

-   путь к файлу;
-   кодировка;
-   callback-функция, вызываемая после получения содержимого файла.

```js
fs.readFile('files/data.txt', 'utf8', (err, data) => {
    if (err) throw err;

    console.log(data);
});
```

Callback-функции передается два аргумента: ошибка и полученные данные в строковом формате. Если операция прошла успешна, то в качестве ошибки передается `null`.

!!! note ""

    Если в `readFile()` не указать кодировку, то данные файла будут возвращены в формате `Buffer`.

Поскольку метод выполняется асинхронно, то не происходит блокировки главного процесса Node.js. Но в некоторых случаях может понадобиться синхронное чтение файла, для этого есть метод `readFileSync()`, но при этом выполнение главного процесса будет заблокировано до тех пор, пока полностью не будет загружено содержимое файла.

```js
const content = fs.readFileSync('files/data.txt', 'utf8');
console.log(content);
```

Node.js `readFileSync()` возвращает результат чтения файла и принимает два параметра:

-   путь к файлу;
-   кодировку.

Обработка и перехват ошибок при использовании `readFileSync()` осуществляется с помощью конструкции `try{...}catch(){...}`.

```js
try {
    const content = fs.readFileSync(
        'files/data.txt',
        'utf8'
    );
    console.log(content);
} catch (e) {
    console.log(e);
}
```

!!! note ""

    Чтобы инициировать ошибку, укажите неправильный путь к файлу.

Методы `readFile()` и `readFileSync()` для работы с файлами используют `Buffer`. Но есть и другой способ считать содержимое файла: создать поток с помощью Node.js `fs.createReadStream()`. Любой поток в Node.js является экземпляром класса `EventEmitter`, который позволяет обрабатывать возникающие в потоке события.

Параметры, принимаемые `fs.createReadStream()`:

-   путь к файлу;
-   объект со следующими настройками:
    -   `encoding` - кодировка (по умолчанию `utf8`);
    -   `mode` - режим доступа (по умолчанию `0o666`);
    -   `autoClose` - если `true`, то при событиях `error` и `finish` поток закроется автоматически (по умолчанию `true`).

```js
const stream = fs.createReadStream(
    'files/data.txt',
    'utf8'
);
stream.on('data', (data) => console.log(data));
stream.on('error', (err) => console.log(`Err: ${err}`));
```

!!! note ""

    Вместо объекта настроек можно передать строку, которая будет задавать кодировку.

Использование потока имеет ряд преимуществ перед `Buffer`:

-   Меньшее использование памяти за счет чтения содержимого по частям;
-   Для объемных файлов время между запросом и ответом существенно сокращается за счет того, что данные начинают поступать по частям, а не после полной загрузки;
-   Возможность перенаправить данные в другой поток с помощью метода `pipe()`.

Для чтения директорий используются методы `readdir()` и `readdirSync()`, для асинхронного и синхронного режимов соответственно.

Node.js `readdir()` работает асинхронно и принимает три аргумента:

-   путь к директории;
-   кодировку;
-   callback-функцию, которая принимает аргументами ошибку и массив файлов директории (при успешном выполнении операции ошибка передается как `null`).

```js
fs.readdir('files', 'utf8', (err, files) => {
    if (err) throw err;

    console.log(files);
});
```

Node.js `readdirSync()` работает синхронно, возвращает массив найденных файлов и принимает два параметра:

-   путь к директории;
-   кодировку.

```js
try {
    const files = fs.readdirSync('files', 'utf8');
    console.log(files);
} catch (e) {
    console.log(e);
}
```

## Создание и запись файлов и директорий

В Node.js файлы могут быть записаны также синхронно и асинхронно. Для асинхронной записи имеется метод `writeFile()`, принимающий следующие аргументы:

-   путь к файлу;
-   данные для записи;
-   параметры записи:
    -   кодировка (по умолчанию `utf8`);
    -   права доступа (по умолчанию `0o666`);
-   callback-функция, которая вызывается по завершению операции и единственным аргументом принимает ошибку (в случае успешной записи передается `null`).

```js
fs.writeFile(
    'files/data.txt',
    'File Content',
    'utf8',
    (err) => {
        if (err) throw err;

        console.log('Done');
    }
);
```

!!! note ""

    Если нет необходимости указывать параметры записи, то третьим параметром Node.js `writeFile()` можно сразу передать callback-функцию.

Для синхронной записи Node.js файла используйте `writeFileSync()`. Метод принимает все те же аргументы, что и `writeFile()` за исключением callback-функции. В качестве значения возвращает `undefined`.

```js
try {
    fs.writeFileSync(
        'files/data.txt',
        'File Content',
        'utf8'
    );
    console.log('Done');
} catch (e) {
    console.log(e);
}
```

!!! note ""

    Как и в случае с `readFileSync()` обработка ошибок происходит с помощью `try{...}catch(){...}`.

Методы `writeFile()` и `writeFileSync()` перезаписывают уже имеющуюся в файле информацию новыми данными. Если вам нужно внести новые данные без удаления старых, используйте методы `appendFile()` и `appendFileSync()`, которые имеют идентичные параметры.

```js
fs.appendFile(
    'files/data.txt',
    '\nFile Content 2',
    'utf8',
    (err) => {
        if (err) throw err;

        console.log('Done');
    }
);
```

Для записи файла через поток ввода имеется метод `fs.createWriteStream()`, который возвращает поток ввода и принимает два параметра:

-   путь к файлу;
-   объект со следующими настройками:
    -   `encoding` - кодировка (по умолчанию `utf8`);
    -   `mode` - режим доступа (по умолчанию `0o666`);
    -   `autoClose` - если `true`, то при событиях `error` и `finish` поток закроется автоматически (по умолчанию `true`).

```js
const stream = fs.createWriteStream(
    'files/data.txt',
    'utf8'
);

stream.on('error', (err) => console.log(`Err: ${err}`));
stream.on('finish', () => console.log('Done'));

stream.write('First line\n');
stream.write('Second line\n');
stream.end();
```

Чтобы создать директорию, используйте методы `mkdir()` и `mkdirSync()`.

Node.js `mkdir()` работает асинхронно и принимает в качестве параметров:

-   путь к директории;
-   объект со следующими настройками:
    -   `recursive` - если `true`, создает директорию и все ее родительские директории согласно указанному пути, если они еще не существуют (по умолчанию `false`, т. е. все родительские директории уже должны быть созданы, иначе будет сгенерирована ошибка);
    -   `mode` - режим доступа, параметр не поддерживается на ОС Windows (по умолчанию `0o777`);
    -   callback-функцию, которая единственным аргументом принимает ошибку, при успешном создании директории передается `null`.

Вторым параметром можно сразу передать callback-функцию.

```js
fs.mkdir('files/dir/subdir', { recursive: true }, (err) => {
    if (err) throw err;

    console.log('Created');
});
```

Node.js `mkdirSync()` создает директорию синхронно и возвращает `undefined`. Обработка ошибок осуществляется через `try{...}catch(){...}`. Метод `mkdirSync()` принимает те же параметры, что и `mkdir()`, за исключением callback-функции.

```js
try {
    fs.mkdirSync('files/dir/subdir', { recursive: true });
    console.log('Done');
} catch (e) {
    console.log(e);
}
```

## Удаление файлов и директорий

Чтобы удалить в Node.js файлы используйте методы `unlink()` и `unlinkSync()`.

Метод `unlink()` асинхронный и принимает имя файла, который нужно удалить, и callback-функцию с ошибкой в качестве параметра (`null`, если удаление прошло успешно).

```js
fs.unlink('files/data.txt', (err) => {
    if (err) throw err;

    console.log('Deleted');
});
```

Для синхронного удаления файла используйте `unlinkSync()`, которому единственным аргументом передается имя файла.

```js
try {
    fs.unlinkSync('files/data.txt');
    console.log('Deleted');
} catch (e) {
    console.log(e);
}
```

Для удаления директорий имеются методы `rmdir()` и `rmdirSync()` соответственно. Они полностью идентичны `unlink()` и `unlinkSync()`, только вместо имени файла принимают имя директории.

Пример `rmdir()`.

```js
fs.rmdir('files/dir', (err) => {
    if (err) throw err;

    console.log('Deleted');
});
```

Пример `rmdirSync()`.

```js
try {
    fs.rmdirSync('files/dir');
    console.log('Deleted');
} catch (e) {
    console.log(e);
}
```

## existsSync()

Проверка наличия в Node.js файла или директории происходит с помощью метода `existsSync()`, который принимает путь к файлу или директории и возвращает либо `true`, либо `false`. Как вы понимаете, Node.Js `existsSync()` работает в синхронном режиме.

```js
try {
    const exists = fs.existsSync('files');
    console.log('Exists: ', exists);
} catch (e) {
    console.log(e);
}
```

Раньше был и Node.js `exists()`, но сейчас он уже официально устарел и не поддерживается.
